# 기초컴퓨터 프로그래밍 시험준비

## C 프로그래밍 언어 개요
```

```
## C 프로그래밍 첫걸음
scanf 함수를 error없이 사용하기 위해서는 #define _CRT_SECURE_NO_WARNINGS 필요
## 자료형과 변수
### 변수 이름 작성규칙
- 변수 일름은 대표적인 식별자로 영어 알파벳, 숫자,밑줄(_)로 구성되며 숫자로는 시작할 수 없다.
- 변수를 선언하면 대입연사자(=)를 사용하여 초기화 하는 과정이 필요하다.
### 기본 자료형
-`오버플로` `언더플로` : 자료형 범주에서 벗어난 값 저장
#### 정수 자료형
##### 정수형 int
- `int`형으로 선언된 변수에는 10진수, 8진수, 16진수의 정수가 저장 될 수 있다.
##### 정수형 short와 long
- 자료형 short는 `short int`라고도 하며 long은 `long int`라고도 한다.
- 정수형은 모두 양수, 0, 음수를 표현할 수 있다.
##### 정수 자료형의 표현 범위
| 자료형 | 크기 | 표현범위 |
|---|:---:|---:|
| signed short | 2바이트 = 16비트| -2^15 ~ 2^15-1 |
| signed int | 4바이트 | -2^31 ~ 2^31-1 |
| signed long | 4바이트 | -2^31 ~ 2^31-1 |
| unsigned short | 2바이트 | 0 ~ 2^16-1 |
| signed long long int | 8바이트 | -2^63 ~ 2^63-1 |

- 부호가 있는 signed 정수에서 저장 공간의 최상위 비트(MSB)는 부호를 나타낸느 역할을 한다.
- 컴퓨터에서 정수의 음수 표현은 -a = ~a(a의 1의보수) + 1 이다.
- 컴퓨터 내부는 (IC:집적회로)로 구성되어 핀1개가 두가지 상태를 나타내므로 2진수를 사용한다.
#### 부동소수 자료형
##### float, double, long bouble
| 자료형 | 크기 | 표현범위 |
|---|:---:|---:|
| float `실수F` | 4바이트 | 10^-38 ~ 10^38 |
| double `실수`| 8바이트 | 10^-308 ~ 10^308 |
| long double `실수L` | 8바이트 | 10^-308 ~ 10^308 |

#### 문자 자료형
##### 문자형 char, signed char, unsigned char
| 자료형 | 크기 | 표현범위 |
|---|:---:|---:|
| char | 1바이트 | -2^7 ~ 2^7-1 |
| signed char | 1바이트 | -2^7 ~ 2^7-1 |
| unsigned char | 1바이트 | 0 ~ 2^8-1 |

- 문자형 자료형은 문자상수('a')나 정수를 직접 저장할 수 있다.
### 상수표현 방법
- 리터럴 상수(literal constant): 이름 없이 있는 그대로 표현한 자료값
  - 정수: 10진수, 8진수`0정수`, 16진수 `0x정수` 
  - 실수형: 소수점 실수, 지수표현 방식
  - 문자상수: 일반문자 `'a'`, 특수문자 `'\n'` 
  - 문자열 상수: "문자열"`
  
- 심볼릭 상수(symbolic constant): 이름이 있고 정해진 하나의 값만으로 사용되는 자료 값
  - const 상수: const double PI = 3.1415; -> 수정할 수 없는 변수
  - 매크로 상수: #define PI 3.1415 -> 전처리 명령어로 정의
  - 열거형 상수: enum bool{FALSE,TRUE} -> 정수 상수 목록 정의
  
## 전처리와 입출력
### 전처리
#### #include
-헤더파일: 전처리 지시자 문장이 있는 텍스트 파일이다.
#### scanf()
- #define _CRT_SECURE_NO_WARNINGS 추가해야 에러안난다.
- #define _CRT_SECURE_NO_DEPRECATE
- 형식지정자로 값을 입력받은 뒤 [Enter]키를 누르면 프로그램이 실행된다.
- 형식 문자열안에 형식지정자 사이에 구분자(sepatator)로 여러개의 문자를 입력받을 수 있다.
- 반환값은 입력된 문자의 개수이다. printf()는 출력되는 문자 개수 (이스케이프 포함)

| 형식지정자 | 콘솔 입력 값의 형태 | 입력 변수 인자 유형 |
|---|:---:|:---|
| %d | 10진수로 인식 | 정수형 int 변수에 입력 값 저장 |
| %lld | 10진수로 인식 | 정수형 long long int 변수에 입력 값 저장 |
| %i | 10진수로 인식(단, 입력 값에 0이 앞에 붙으면 8진수, 0x가 붙으면 16진수로 인식하여 저장) | 정수형 int 변수에 입력 값 저장 |
| %u | unsigned int로 인식 | 정수형 unsigned int 변수에 입력 값 저장 |
| %0 | 8진수로 인식 | 정수형 int 변수에 입력 값 저장 |
| %x,%X | 16진수로 인식 | 정수형 int 변수에 입력 값 저장 |
| %f | 부동 소수로 인식 | 부동소수형 float 변수에 입력 값 저장 |
| %lf | 부동 소수로 인식 | 부동소수형 double 변수에 입력 값 저장 |
| %e,%E | 지수 형태의 부동소수로 인식 | 부동소수형 float 변수에 입력 값 저장 |
| %c | 문자로 인식 | 문자형 char 변수에 입력 값 저장 |
| %s | 일련의 문자인 문자열(string)로 인식 | 문자열을 저장할 배열에 입력 값 저장 |
| %p | 주소(address) 값으로 인식 | 정수형 unsigned int 변수에 입력 값 저장 |

#### getchar(), putchar()
- 함수 getchar()는 인자없이 함수를 호출하며 입력된 문자 값을 자료형 char나 정수형으로 선언된 변수에 저장할 수 있다.
- char ch = getchar();
- int ch getchar();
- putchar(문자) -> 문자전용 출력함수
- puts() -> 문자열 전용 
## 연산자와 연산식
- 연산식(expression)
  - 변수와 다양한 리터럴 상수 그리고 함수의 호출 등으로 구성되는 표현식
  - 현산식은 항상 하나의 결과값을 가짐
- 연산자(operator): 이미 정의된 연산을 수행하는 문자 또는 문자조합기호 `+` `-` `*` `/`
- 피연산자(operand): 연산에 참여하는 변수나 상수
--------
### 다양한 연산자

#### 단(일)항(unary) 연산자
- 전위: `++a`전위 증가연산자 `sizeof()`sizeof 연산자 `(int)`자료형 변환연산자 `-` 부호연산자 
- 후위: `a--` 후위 감소연산자 `a++` 후위 증가현산자
##### 증가 감소 연산자
```
  n++: 현재값을 연산의 결과값으로 한 후, 1을 더함
  ++n: 1을 더한 결과를 연산의 결과값으로 함
  n--: 현재값을 연산의 결과값으로 한 후, 1을 뺌
  --n: 1을 뺀 결과를 연산의 결과값으로 함
```
#### 이항(binary) 연산자
`%` 산술 연산자 `&&` 논리 연산자 `>=` 비교(관계) 연산자 `^` 비트 연산자 `+=` 축약대입 대입연산자 `>>` 쉬프트 연산자
##### 산술연산자
-
##### 논리연산자 
`&&(and)` `||(or)` `!(not)`
- 결과가 참이면 1 거짓이면 0을 반환
- `0` `0.0` `'\0'` `NULL` 은 거짓을 의미 이외 모든 문자와 정수와 실수, 문자열은 모두 참을 의미
- &&와 ||의 단축평가: 
  - 피연산자 두 개 중 왼쪽 피연산자만으로 논리연산 결과가 결정된다면 오른쪽 피연산자는 평가하지 않는 방식

##### 비트 논리연산자
`&(AND)` `|(OR)` `^(XOR)` `~(NOT)`
| 연산자 | 이름 | 의미 |
|---|:---:|---:|
| `&` | 비트 AND | 비트가 모두 1이면 1, 아니면 0 |
| `ㅣ` | 비트 OR |  비트가 적어도 하나 1이면 1, 아니면 0|
| `^` | 비트 배타적 XOR | 비트가 서로 다르면 1, 같으면 0 |
| `~` | 비트 NOT | 비트가 0이면 1, 0이면 1 |

#### 삼항(ternary) 연산자
`?:`가 유일하다
- 조건에 따라 주어진 피연산자가 결과값이 되는 삼항연산자
--------
#### 비트이동 연산자
- Shift right `>>`
| a >> n | 홀수 | 짝수 |
|---|:---:|---:|
| + | a/(2^n) (몫) | a/(2^n) |
| - | a/(2^n)-1 | a/(2^n) |

- Shift left `<<`

- 올림변환: 작은 범주의 자료형(int)에서 보다 큰 범주인 형(double)으로의 형변환 방식
- 내림변환: 큰 범주의 자료형(double)에서 보다 작은 범주인 형(int)으로의 형변환 방식
- 명시적(강제) 형변환: 소스에서 직접 형변환 연산자를 사용하는 방식
- 묵시적(자동) 형변환: 컴파일러가 알아서 자동으로 수행하는 방식
## 조건
- 조건 선택: 두개 또는 여러개 중의 하나를 선택하는 구조
`if` `if else` `if else if` `nested if` `switch` 
- 반복: 반복 몸체인 여러 문장을 여러번 반복하는 구조
`for` `while` `do while`
- 분기처리: 정해진 장소로 이동하는 구조
`break` `continue` `goto` `return`

### if 문
```C
  조건식이 0(거짓)이 아니면 문장을 실행
  if(조건식)
  {
    실행문장;
  }
  
  실행문장이 한 문장이면 {} 없이 tab 으로 표현하기도 함 
  if(조건식)
    실행문장;
```
### 조건연산자(삼항연산자)
```C
  <형식> 조건식 ? true : false ; -> 2,3, 번째 피연산자는 모든 자료형 가능
  <예시> abs = x>=0 ? x : -x;
```
### switch 문
```C
  switch(exp){   -> 식의 결과는 문자형 또는 정수형이어야 한다.
    case value1: -> 정수 또는 문자형의 상수이어야 한다. ("hello"같은 문자열 안됨)
      stmt1;
      break;     -> break를 만나면 switch 문이 종료된다.
      
    case value2:
      stmt2;
      break;
      
    case value3:
      stmt3;
      break;
      
    default:     -> 위의 case 값과 일치하지 않으면 default 문장 실행 (default는 무조건 실행) 
      stmt4;
      break;
  }
```
#### switch 문 주의점
- 연산식 결과는 정수형 또는 문자형
- 각 case 뒤에 나오는 식은 상수식
  - 상수식에는 변수와 const 상수 사용 불가능
  - 리터럴 상수와 매크로 상수의 연산식은 사용가능 `'A'`, `#define`
- default
  - 선택적으로 사용하며, 어디에 위치해도 모든 case 처리를 하지 않은 경우 실행
  - 다른 case가 뒤에 있다면 break가 필요

## random 함수
```C
  #include <stdlib.h> 추가
  random = rand(); 0~32767 난수생성 
  rand()%9 = 0~9 까지 난수생성
  
  #include <time.h> 추가
  srand(time(NULL)); -> 실행마다 다른 랜덤생성 (rand() 함수에 무작위의 시드값을 준다)
```
## 반복
```C
  순환 또는 루프(loop)라는 표현도 함께사용
  반복몸체: 반복조건을 만족하면 일정하게 반복되는 블록
  while,do-while,for 세 가지 종류의 반복구문 존재
```
### while 문
```C
  조건이 참이면 실행(조건에 따라서 한번도 실행 안할수있음)
  while(조건식)
  {
    //반복몸체(loop body);
    참일때;
  }
```
### do-while 문
```C
  무조건 실행후 조건비교(적어도 1번은 실행을 한후에 조건비교)
  do
  {
    //반복몸체(loop body);
    실행문;
  }while(조건식);
```
  - 반복 조건을 나중에 검사해야 하는 반복에 적합 
  - (센티널 값: 반복의 종료를 알리는 특정한 자료 값) 검사에 유용

### for 문
```C
  for(init(초기화); cond(조건식); inc(제어 변수의 증감식))
  {
    //반복몸체(loop body);
  }
  초기화 -> [ 조건식 -> 반복몸체 -> 변수의 증감식 -> 조건식 ] -> 종료;
```
    break: 블럭탈출
    continue: loop 문에서 밑에 문장을 수행하지 않고 다음 loop 진행
    continue는 자신이 속한 가장 근접한 복복에서 다음 반복을 
 
### for 문과 while 문의 비교
- for 문
-- 주로 반복 횟수를 제어하는 제어 변수를 사용
-- 초기화와 증감 부분이 있는 반복문에 적합

- while 문
-- 구조가 간단하므로 다양한 구문에 이용
-- 반복 횟수가 정해지지 않고 특정조건에 따라 반복을 결정하는 구문에 적합
    
### 반복 조건에서 주의
- 반복 조건에서 등호(==)나 부등호(!=) 또는 대입연산자(=)의 피연산자로 실수의 사용은 주의를 필요로 한다.
- 예를 들어 d != 1.0으로 하면 실수 연산의 오차로 인해 조건식이 항상 참인 결과로 무한히 반복 될 수 있다.

### 무한 반복
goto: 무조건 레이블이 위치한 다음 문장으로 실행 순서를 이동하는 문장 <br>
`for(;;)` `for(;1;)` `while(1)` `do-while(1)`










